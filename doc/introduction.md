# KXCore 项目文档

## 概述

KXCore 是一个基于 la32r 指令集的乱序多发射 CPU, 支持3发射队列，双提交同时具有分支预测，Cache等优化设计。

我们实现了 LoongArch32 精简版，支持：
- **基础指令集**：包含算术运算、逻辑运算、移位、分支跳转等指令
- **访存指令**：支持字节、半字、字的加载存储操作
- **系统指令**：ERTN、SYSCALL、EBREAK等特权指令
- **CSR操作**：CSRRD、CSRWR、CSRXCHG等控制状态寄存器指令
- **中断异常处理**：完整的异常处理机制和中断控制
- **AXI总线接口**：支持标准AXI3总线协议

### 核心参数
- **数据位宽**：32位
- **取指宽度**：四路取指 (fetchWidth = 4)
- **译码宽度**：2路译码 (coreWidth = 2)
- **发射宽度**：3个发射队列，总计4个执行单元
  - MEM IQ: 发射宽度1，队列深度12
  - UNQ IQ: 发射宽度1，队列深度12  
  - INT IQ: 发射宽度2，队列深度20
- **退休宽度**：2路退休 (retireWidth = 2)
- **物理寄存器**：80个物理寄存器，32个逻辑寄存器
- **ROB大小**：32个条目的重排序缓冲区
- **取指缓冲区**：32个条目 (fbNum = 32)
- **取指目标队列**：32个条目 (ftqNum = 32)
- **返回地址栈**：32个条目 (rasNum = 32)

## 总体架构

KXCore 使用了前后端架构，前端4阶段，后端6阶段。

### 顶层模块层次
```
Core (核心处理器)
├── TLB (地址转换缓冲区)
├── CSR (控制状态寄存器)
├── FrontEnd (前端)
│   ├── ICache (指令缓存)
│   ├── BranchPredictor (分支预测器)
│   │   ├── BIM (分支指令缓冲区)
│   │   ├── BTB (分支目标缓冲区)
│   │   └── RAS (返回地址栈)
│   ├── FetchBuffer (取指缓冲区)
│   └── FTQ (取指目标队列)
└── BackEnd (后端)
    ├── Decoder (译码器)
    ├── RenameMapTable (重命名映射表)
    ├── RenameFreeList (重命名空闲列表)
    ├── RenameBusyTable (重命名忙表)
    ├── BasicDispatcher (基本分派器)
    ├── IssueUnits (发射单元) × 3
    │   ├── MemIssueUnit (内存发射单元)
    │   ├── UnqIssueUnit (特殊发射单元)
    │   └── IntIssueUnit (整数发射单元)
    ├── ExecutionUnits (执行单元) × 4
    │   ├── MemExeUnit (内存执行单元)
    │   ├── UniqueExeUnit (特殊执行单元)
    │   └── ALUExeUnit (ALU执行单元) × 2
    ├── FullyPortedRF (全端口寄存器文件)
    └── ReorderBuffer (重排序缓冲区)
```

### 前端设计

![前端架构图](KXCore_FrontEnd.png)

前端采用4级流水线设计，包含以下阶段：

#### Stage 0: 预取指阶段

- **PC生成**：支持顺序取指和重定向（后端/预测单元预测结果）

#### Stage 1: 分支预测与取指阶段 

- **ICache**：指令缓存，加快前端取指速度

- **TLB**:翻译虚拟地址

- **分支预测**：通过BTB、BIM单元预测分支结果，帮助PC进行重定向

#### Stage 2: 预解码阶段 

- **RAS**：函数调用地址堆栈
- **预解码**:提前完成控制流指令的解码，帮助PC进行重定向，降低分支预测失败代价

#### Stage 3: 发送指令阶段

- **取指缓冲区 (FetchBuffer)**：16个条目，用于缓冲取指结果
- **取指目标队列 (FTQ)**：32个条目，缓存取指地址和分支信息，减少后端流水线寄存器存储压力

### 后端设计

![后端架构图](KXCore_BackEnd.png)

#### Stage 0: 译码与重命名1阶段 
**主要模块**：[`Decoder`](../superscalar/src/KXCore/superscalar/core/backend/Decode/Decoder.scala)

- **指令译码**：将LoongArch32指令译码为内部微操作(MicroOp)
  - 支持算术运算、逻辑运算、访存、分支跳转、CSR操作等指令类型
  - 通过译码表确定指令的功能单元类型(FUType)和发射队列类型(IQType)
- **操作数识别**：识别源寄存器(lrs1/lrs2)和目标寄存器(ldst)
- **功能单元分配**：根据指令类型分配到对应的功能单元
  - ALU指令 → INT发射队列 → ALU执行单元
  - 访存指令 → MEM发射队列 → 内存执行单元
  - 乘除法指令 → UNQ发射队列 → 乘除法执行单元
  - CSR/系统指令 → UNQ发射队列 → 特殊执行单元
- **寄存器重命名**：逻辑寄存器到物理寄存器的映射，消除WAR和WAW冲突

#### Stage 1: 重命名2与分派阶段 
**主要模块**：[`BasicDispatcher`](../superscalar/src/KXCore/superscalar/core/backend/Dispatch/Dispatcher.scala)、重命名相关模块

- **依赖关系解析**：建立指令间的数据依赖关系，确保正确的执行顺序
- **物理寄存器分配**：
  - `RenameFreeList`：维护空闲物理寄存器列表
  - `RenameMapTable`：维护逻辑寄存器到物理寄存器的映射表
  - `RenameBusyTable`：跟踪物理寄存器的忙/闲状态
- **ROB分配**：为每条指令分配重排序缓冲区条目，支持按序提交
- **发射队列选择**：根据指令的IQType将指令分发到对应发射队列
  - 采用BasicDispatcher策略，假设最坏情况所有指令都发送到同一个队列
- **资源可用性检查**：确保有足够的物理寄存器、ROB条目和发射队列空间

#### Stage 2: 发射阶段
**主要模块**：发射单元 ([`IssueUnit`](../superscalar/src/KXCore/superscalar/core/backend/Issue/IssueUnit.scala))

KXCore配置了3个专用发射队列，采用乱序发射策略：

1. **内存发射队列 (MEM IQ)**：
   - 处理所有访存指令 (LD_B/LD_H/LD_W/ST_B/ST_H/ST_W等)
   - 发射宽度：1，队列深度：12
   - 支持地址计算和数据转发
   
2. **特殊发射队列 (UNQ IQ)**：
   - 处理特殊指令：
     - 乘除法指令 (MUL_W/MULH_W/DIV_W/MOD_W等)
     - CSR操作 (CSRRD/CSRWR/CSRXCHG系列)
     - 系统指令 (BREAK/SYSCALL/ERTN)
     - 计数器指令 (RDCNTID_W/RDCNTVH_W/RDCNTVL_W)
   - 发射宽度：1，队列深度：12
   
3. **整数发射队列 (INT IQ)**：
   - 处理整数运算指令 (ADD/SUB/AND/OR/XOR/SLT等)
   - 发射宽度：2，队列深度：20
   - 支持双发射，提高整数运算吞吐量

**发射机制**：
- 基于数据依赖的动态调度
- 支持唤醒机制，当操作数就绪时唤醒等待的指令
- 每个发射队列独立管理，避免队列间冲突

#### Stage 3: 执行阶段
**主要模块**：执行单元 ([`ExecutionUnit`](../superscalar/src/KXCore/superscalar/core/backend/Execute/ExecutionUnit.scala))

KXCore配置了4个执行单元，支持并行执行：

1. **ALU执行单元 (ALUExeUnit)** × 2：
   - 支持基本算术运算：ADD、SUB、SLT、SLTU等
   - 支持逻辑运算：AND、OR、XOR、NOR等
   - 支持移位运算：SLL、SRL、SRA等
   - 支持分支指令：BEQ、BNE、BLT、BGE等
   - 每个ALU单元支持1个读端口，可并行执行两条整数指令

2. **内存执行单元 (MemExeUnit)**：
   - 集成数据缓存(DCache)的访存执行单元
   - 支持字节、半字、字的加载存储操作
   - 集成地址计算和TLB访问
   - 通过AXI总线与外部内存交互
   - 支持异常处理（地址异常、TLB缺失等）

3. **特殊执行单元 (UniqueExeUnit)**：
   - **乘法器**：3级流水线Wallace乘法器，支持32位乘法
   - **除法器**：Booth除法器，支持有符号和无符号除法
   - **CSR操作**：完整的控制状态寄存器访问和管理
   - **系统指令**：BREAK、SYSCALL、ERTN等特权指令
   - **计数器访问**：稳定计数器读取

**执行特性**：
- 支持数据转发，减少数据冒险
- 异常检测和处理
- 分支预测验证和重定向

#### Stage 4: 写回阶段
**主要功能**：执行结果写回和状态更新

- **结果写回**：执行结果写回物理寄存器文件 (`FullyPortedRF`)
  - 支持多个写端口，对应不同执行单元
  - ALU单元：2个写端口
  - 内存单元：1个写端口  
  - 特殊单元：1个写端口（乘法）+ 1个写端口（除法）
- **唤醒机制**：通过写回端口唤醒等待相关数据的指令
  - 广播写回的物理寄存器号到所有发射队列
  - 更新发射队列中等待指令的操作数就绪状态
- **ROB更新**：将执行结果和状态写入重排序缓冲区
- **异常信息收集**：收集执行阶段产生的异常信息

#### Stage 5: 提交阶段
**主要模块**：重排序缓冲区 ([`ReorderBuffer`](../superscalar/src/KXCore/superscalar/core/backend/Commit/ReorderBuffer.scala))

- **按序提交**：保证指令按程序顺序提交，维护程序语义正确性
  - ROB采用环形缓冲区设计，支持32个条目
  - 每周期最多提交2条指令 (retireWidth = 2)
  - 只有ROB头部的指令才能提交
- **异常处理**：处理执行阶段的异常和中断
  - 支持精确异常：异常指令之前的指令正常提交，之后的指令被丢弃
  - 异常类型：地址异常、指令异常、系统调用、中断等
  - 异常处理时自动刷新流水线和分支预测状态
- **分支重定向**：处理分支预测错误
  - 验证分支预测结果，如有错误触发重定向
  - 刷新错误路径上的所有指令
  - 恢复分支预测器状态和寄存器重命名状态
- **架构状态更新**：更新架构可见的处理器状态
  - 释放已提交指令占用的物理寄存器
  - 更新程序计数器(PC)
  - 更新CSR寄存器状态
  - 向前端发送提交信息，更新取指目标队列(FTQ)

## 关键优化设计

### 乱序执行核心机制

#### 寄存器重命名系统
KXCore采用了业界先进的寄存器重命名技术：
- **物理寄存器池**：80个物理寄存器 vs 32个逻辑寄存器，提供2.5倍的寄存器容量
- **重命名映射表 (RenameMapTable)**：维护逻辑到物理寄存器的动态映射
  - 支持回滚操作，异常时快速恢复寄存器状态
  - 提交时的映射更新和旧寄存器释放
- **空闲列表 (RenameFreeList)**：高效管理可用物理寄存器
  - 支持每周期2个寄存器的分配和释放
  - 采用循环队列设计，避免分配冲突
- **忙表 (RenameBusyTable)**：跟踪寄存器数据就绪状态
  - 与唤醒机制紧密集成，支持快速状态更新
  - 消除WAR和WAW数据冲突，提高并行度

#### 动态调度机制
- **基于数据流的调度**：指令根据操作数就绪状态动态发射
- **年龄矩阵选择**：保证老指令优先发射，维护程序语义
- **唤醒传播网络**：写回结果快速传播到所有等待指令
- **发射队列独立管理**：3个发射队列并行工作，提高发射带宽

#### 推测执行与恢复
- **分支预测推测**：基于分支预测结果的推测执行
- **检查点机制**：关键状态的快照和恢复
- **流水线刷新**：预测错误时的快速流水线清空
- **状态回滚**：寄存器重命名状态的精确恢复

#### 精确异常处理
- **ROB序列化**：通过重排序缓冲区保证指令按序提交
- **异常检测点**：在提交阶段统一处理所有异常
- **上下文保存**：异常时的完整处理器状态保存
- **异常向量表**：支持多种异常类型的向量化处理
- **数据依赖检测**：在发射队列中检测操作数就绪状态
- **唤醒机制**：写回结果时广播唤醒依赖指令
- **乱序发射**：操作数就绪的指令可以乱序发射执行
- **按序提交**：通过ROB保证指令按程序顺序提交

### 分支预测机制
KXCore采用了先进的混合分支预测器架构，实现高精度的分支预测：

#### 多级分支预测器组合
- **分支指令缓冲区 (BIM)**：2048组的分支历史表，采用2位饱和计数器预测分支方向
  - 支持动态学习和更新机制，能够适应不同的分支行为模式
  - 通过双端口设计支持并发读写操作
- **分支目标缓冲区 (BTB)**：128组2路组相联设计，预测分支目标地址
  - 支持扩展BTB设计，处理长距离跳转的目标地址存储
  - 采用LRU替换策略，优化缓存命中率
  - 集成分支类型识别（条件分支、无条件跳转、间接跳转）
- **返回地址栈 (RAS)**：32条目的函数调用栈，专门优化函数返回预测
  - 硬件实现的栈结构，避免软件栈管理开销
  - 支持深度嵌套函数调用的高精度预测

#### 高级预测特性
- **分支预测融合**：BIM和BTB协同工作，分别处理方向和目标预测
- **预测失败恢复**：支持分支预测失败时的快速恢复机制和状态回滚
- **多取指支持**：支持每周期4条指令的并行分支预测
- **预测更新策略**：采用写回阶段的延迟更新，避免预测器状态不一致

### 缓存系统
KXCore实现了高性能的缓存层次结构：

#### 指令缓存 (ICache)
- **缓存配置**：支持可配置的容量和相联度
- **预取机制**：支持指令预取和缓存一致性协议
- **多级流水线**：3级流水线设计，优化访问延迟
- **CACOP指令支持**：支持缓存操作指令，实现精确的缓存控制

#### 数据缓存 (DCache) 
- **集成设计**：与内存执行单元紧密集成
- **写回策略**：支持写回和写穿策略
- **缓存一致性**：支持多级缓存一致性协议
- **异常处理**：集成缓存异常检测和处理机制

### 虚拟内存管理系统

#### 高性能TLB设计
KXCore实现了完整的LoongArch32虚拟内存管理：
- **TLB条目管理**：支持可配置数量的TLB条目
- **页面大小支持**：同时支持4KB和2MB页面
- **地址空间标识符(ASID)**：10位ASID支持多进程地址空间隔离
- **全局页面支持**：支持全局页面标记，优化内核页面访问
- **特权级检查**：硬件特权级验证，支持4级特权模式

#### TLB操作指令
- **TLBSRCH**：TLB搜索指令，支持虚拟地址查找
- **TLBRD**：TLB读取指令，读取指定TLB条目
- **TLBWR**：TLB写入指令，更新指定TLB条目  
- **TLBFILL**：TLB填充指令，处理TLB缺失
- **INVTLB**：TLB无效指令，支持多种无效策略

#### 内存访问类型(MAT)
- **缓存一致性控制**：支持多种内存访问类型
- **页面权限管理**：读、写、执行权限的硬件检查
- **脏位管理**：自动脏位更新和检查

#### 直接映射窗口(DMW)
- **快速地址转换**：绕过TLB的直接地址映射
- **特权级控制**：支持不同特权级的访问控制
- **段式地址映射**：支持虚拟段到物理段的直接映射

### 高性能算术运算单元

#### Wallace树乘法器
KXCore实现了先进的Wallace树乘法器：
- **Booth编码优化**：采用Booth-2编码减少部分积数量
- **3级流水线设计**：深度流水线优化，支持每周期一次乘法操作
- **混合精度支持**：支持有符号和无符号32位乘法
- **并行压缩树**：使用压缩树结构减少加法器延迟

#### Booth除法器
高效的除法运算实现：
- **Booth算法**：支持有符号和无符号除法
- **逐位除法**：32位数据宽度的完整除法支持
- **零除检测**：硬件级零除异常检测和处理
- **余数计算**：同时输出商和余数，支持MOD指令

### 高级系统特性

#### 完整的CSR系统
KXCore实现了LoongArch32的完整控制状态寄存器系统：
- **处理器状态管理**：CRMD、PRMD、EUEN等状态寄存器
- **异常处理寄存器**：ERA、EENTRY、ECFG、ESTAT等
- **TLB管理寄存器**：TLBIDX、TLBEHI、TLBELO0/1等
- **定时器系统**：TCFG、TVAL、TICLR定时器寄存器
- **稳定计数器**：64位高精度系统计数器

#### 中断处理系统
- **8位中断输入**：支持多种中断源
- **中断优先级**：硬件中断优先级仲裁
- **中断屏蔽**：灵活的中断使能和屏蔽控制
- **中断向量化**：支持向量化中断处理

#### 调试和验证支持
- **Difftest接口**：完整的Difftest协议支持，便于功能验证
- **性能计数器**：内置性能监控和分析功能
- **调试寄存器**：支持实时寄存器状态监控
- **波形调试**：详细的内部信号输出，支持深度调试

#### 先进的设计方法学
- **参数化设计**：高度可配置的硬件参数
- **模块化架构**：清晰的模块边界和接口定义
- **流水线设计**：深度优化的10级流水线
- **时钟域管理**：统一的时钟和复位设计
  - 异常指令前的指令正常提交
  - 异常指令后的指令被取消
- **中断处理**：支持8位中断输入，完整的中断控制机制

## 技术创新与亮点

### 1. 先进的微架构设计
- **深度乱序执行**：10级流水线设计，支持高效的乱序执行
- **多发射架构**：3个发射队列，4个执行单元的并行处理能力
- **智能调度算法**：基于数据流的动态调度，最大化指令级并行

### 2. 高性能算术单元
- **Wallace树乘法器**：采用先进的Booth编码和压缩树技术
- **流水线除法器**：高效的Booth除法器实现
- **并行ALU设计**：支持双发射的整数运算单元

### 3. 先进的分支预测
- **混合预测器**：BIM、BTB、RAS的协同预测
- **高容量设计**：2048组BIM + 128组BTB，提供高预测精度
- **快速恢复机制**：预测失败时的高效状态恢复

### 主要数据结构

#### 微操作 (MicroOp)
KXCore的核心数据结构，包含指令执行所需的所有信息：
- **基本信息**：PC、指令编码、ROB索引、FTQ索引
- **寄存器信息**：逻辑源寄存器(lrs1/lrs2)、逻辑目标寄存器(ldst)
- **重命名信息**：物理源寄存器(prs1/prs2)、物理目标寄存器(pdst)
- **控制信息**：功能单元类型、发射队列类型、执行命令
- **调试信息**：用于调试和验证的附加信息

#### 发射队列槽位 (IssueSlot)
发射队列的基本单元，管理单条指令的发射：
- **有效性**：指示槽位是否包含有效指令
- **就绪检测**：检查操作数是否就绪
- **唤醒逻辑**：响应写回端口的唤醒信号
- **发射授权**：参与发射仲裁并获得执行许可

### 关键算法

#### 发射选择算法
采用年龄矩阵(Age Matrix)或优先级编码器选择最老的就绪指令：
```
for each issue queue:
  1. 找出所有操作数就绪的指令
  2. 在就绪指令中选择最老的指令
  3. 根据发射宽度选择多条指令发射
  4. 更新发射队列状态
```

#### 唤醒算法
写回结果时广播唤醒依赖指令：

对于每次写回
  1. 广播写回的物理寄存器号
  2. 所有发射队列检查依赖关系
  3. 更新等待该寄存器的指令状态
  4. 标记操作数就绪的指令可发射


### 性能特性

### 性能特性与优化

### 指令吞吐量优化
- **理论峰值性能**：每周期最多取指4条、译码2条、发射4条、提交2条指令
- **高并发设计**：
  - 前端：4路并行取指，支持跨Cache Line取指
  - 后端：3个独立发射队列，4个并行执行单元
  - 提交：2路并行提交，支持高吞吐量指令退休

### 延迟优化策略
- **数据转发网络**：执行单元间的快速数据转发，减少数据冒险延迟
- **分支预测优化**：多级分支预测器减少分支延迟惩罚
- **缓存层次优化**：指令和数据缓存的智能预取和替换策略
- **流水线平衡**：前端4级+后端6级的平衡设计，避免流水线气泡

### 功耗管理
- **时钟门控**：细粒度的时钟门控设计，降低动态功耗
- **模块化电源**：支持模块级电源管理
- **流水线优化**：减少不必要的状态转换和数据移动

### 面积效率
- **资源复用**：多个功能单元间的资源共享
- **存储器优化**：高效的存储器设计和布局
- **逻辑优化**：深度的逻辑综合和优化

## 技术实现细节

## 项目结构说明

### 源代码组织
```
KXCore/
├── common/                    # 通用模块
│   ├── src/KXCore/common/
│   │   ├── Instruction.scala  # 指令定义和解码
│   │   ├── Parameters.scala   # 参数配置
│   │   ├── Stage.scala       # 流水线阶段基类
│   │   ├── peripheral/       # 外设接口
│   │   └── utils/           # 工具类
├── superscalar/              # 超标量架构实现
│   ├── src/KXCore/superscalar/
│   │   ├── Parameters.scala  # 超标量参数
│   │   ├── Top.scala        # 顶层模块
│   │   └── core/            # 核心实现
│   │       ├── Core.scala   # 核心主模块
│   │       ├── frontend/    # 前端模块
│   │       └── backend/     # 后端模块
└── build/                   # 生成的Verilog文件
```

### 构建流程
1. **Scala编译**：使用mill构建工具编译Scala源代码
2. **Chisel生成**：通过Chisel将Scala硬件描述转换为Verilog
3. **SystemVerilog输出**：生成可综合的SystemVerilog代码
4. **仿真验证**：使用生成的代码进行功能和性能验证

### 配置参数
主要配置参数定义在`Parameters.scala`中：
- **CommonParameters**：通用参数（数据宽度、地址宽度等）
- **FrontendParameters**：前端参数（取指宽度、缓冲区大小等）
- **BackendParameters**：后端参数（发射宽度、ROB大小等）
- **CoreParameters**：整体核心参数，组合各模块参数

### 扩展性设计
- **参数化设计**：大部分配置通过参数控制，便于定制
- **模块化结构**：各功能模块独立，便于替换和升级
- **接口标准化**：使用标准的Chisel接口，便于集成
- **多核扩展**：设计支持多核扩展的可能性

