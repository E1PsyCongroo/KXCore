package KXCore.common

import chisel3._
import chisel3.util._
import chisel3.util.experimental.decode._

object InstructionType extends ChiselEnum {
  val TYPE_2R, TYPE_3R, TYPE_4R, TYPE_2RI12, TYPE_2RI14, TYPE_2RI16, TYPE_1RI20, TYPE_I26 = Value
}

case class Instruction(
    val name: String,
    val itype: InstructionType.Type,
    val inst: BitPat,
) extends DecodePattern {
  require(
    inst.getWidth == 32,
    s"Instruction pattern must be 32 bits long, got: ${inst.getWidth} bits",
  )
  def bitPat: BitPat    = inst
  def rd: BitPat        = inst(4, 0)
  def rj: BitPat        = inst(9, 5)
  def rk: BitPat        = inst(14, 10)
  def ui5: BitPat       = inst(14, 10)
  def si12: BitPat      = inst(21, 12)
  def ui12: BitPat      = inst(21, 12)
  def csr: BitPat       = inst(23, 12)
  def cacopCode: BitPat = inst(4, 0)
  def si20: BitPat      = inst(24, 5)
  def si14: BitPat      = inst(23, 12)
  def si16: BitPat      = inst(25, 10)
  def si26: BitPat      = inst(0, 9) ## inst(25, 10)
}

object Instruction {
  import InstructionType._

  /* Arithmetic Operations Instructions */
  val ADD_W     = Instruction("ADD.W", TYPE_3R, BitPat("b0000 0000 0001 00000 ????? ????? ?????"))
  val SUB_W     = Instruction("SUB.W", TYPE_3R, BitPat("b0000 0000 0001 00010 ????? ????? ?????"))
  val SLT       = Instruction("SLT", TYPE_3R, BitPat("b0000 0000 0001 00100 ????? ????? ?????"))
  val SLTU      = Instruction("SLTU", TYPE_3R, BitPat("b0000 0000 0001 00101 ????? ????? ?????"))
  val NOR       = Instruction("NOR", TYPE_3R, BitPat("b0000 0000 0001 01000 ????? ????? ?????"))
  val AND       = Instruction("AND", TYPE_3R, BitPat("b0000 0000 0001 01001 ????? ????? ?????"))
  val OR        = Instruction("OR", TYPE_3R, BitPat("b0000 0000 0001 01010 ????? ????? ?????"))
  val XOR       = Instruction("XOR", TYPE_3R, BitPat("b0000 0000 0001 01011 ????? ????? ?????"))
  val MUL_W     = Instruction("MUL.W", TYPE_3R, BitPat("b0000 0000 0001 11000 ????? ????? ?????"))
  val MULH_W    = Instruction("MULH.W", TYPE_3R, BitPat("b0000 0000 0001 11001 ????? ????? ?????"))
  val MULH_WU   = Instruction("MULH.WU", TYPE_3R, BitPat("b0000 0000 0001 11010 ????? ????? ?????"))
  val DIV_W     = Instruction("DIV.W", TYPE_3R, BitPat("b0000 0000 0010 00000 ????? ????? ?????"))
  val MOD_W     = Instruction("MOD.W", TYPE_3R, BitPat("b0000 0000 0010 00001 ????? ????? ?????"))
  val DIV_WU    = Instruction("DIV.WU", TYPE_3R, BitPat("b0000 0000 0010 00010 ????? ????? ?????"))
  val MOD_WU    = Instruction("MOD.WU", TYPE_3R, BitPat("b0000 0000 0010 00011 ????? ????? ?????"))
  val SLTI      = Instruction("SLTI", TYPE_2RI12, BitPat("b0000 001000 ???????????? ????? ?????"))
  val SLTUI     = Instruction("SLTUI", TYPE_2RI12, BitPat("b0000 001001 ???????????? ????? ?????"))
  val ADDI_W    = Instruction("ADDI.W", TYPE_2RI12, BitPat("b0000 001010 ???????????? ????? ?????"))
  val ANDI      = Instruction("ANDI.W", TYPE_2RI12, BitPat("b0000 001101 ???????????? ????? ?????"))
  val ORI       = Instruction("ORI.W", TYPE_2RI12, BitPat("b0000 001110 ???????????? ????? ?????"))
  val XORI      = Instruction("XORI.W", TYPE_2RI12, BitPat("b0000 001111 ???????????? ????? ?????"))
  val LU12I_W   = Instruction("LU12I.W", TYPE_1RI20, BitPat("b0001010 ???????????????????? ?????"))
  val PCADDU12I = Instruction("PCADDU12I", TYPE_1RI20, BitPat("b0001110 ????? ????? ????? ????? ?????"))

  /* Shift Arithmetic Instructions*/
  val SLL_W  = Instruction("SLL.W", TYPE_3R, BitPat("b0000 0000 0001 01110 ????? ????? ?????"))
  val SRL_W  = Instruction("SRL.W", TYPE_3R, BitPat("b0000 0000 0001 01111 ????? ????? ?????"))
  val SRA_W  = Instruction("SRA.W", TYPE_3R, BitPat("b0000 0000 0001 10000 ????? ????? ?????"))
  val SLLI_W = Instruction("SLLI.W", TYPE_3R, BitPat("b0000 0000 0100 00001 ????? ????? ?????"))
  val SRLI_W = Instruction("SRLI.W", TYPE_3R, BitPat("b0000 0000 0100 01001 ????? ????? ?????"))
  val SRAI_W = Instruction("SRAI.W", TYPE_3R, BitPat("b0000 0000 0100 10001 ????? ????? ?????"))

  /* Transfer Instructions */
  val JIRL = Instruction("JIRL", TYPE_2RI16, BitPat("b010011 ???????????????? ????? ?????"))
  val B    = Instruction("B", TYPE_I26, BitPat("b010100 ???????????????? ????? ?????"))
  val BL   = Instruction("BL", TYPE_I26, BitPat("b010101 ???????????????? ????? ?????"))
  val BEQ  = Instruction("BEQ", TYPE_2RI16, BitPat("b010110 ???????????????? ????? ?????"))
  val BNE  = Instruction("BNE", TYPE_2RI16, BitPat("b010111 ???????????????? ????? ?????"))
  val BLT  = Instruction("BLT", TYPE_2RI16, BitPat("b011000 ???????????????? ????? ?????"))
  val BGE  = Instruction("BGE", TYPE_2RI16, BitPat("b011001 ???????????????? ????? ?????"))
  val BLTU = Instruction("BLTU", TYPE_2RI16, BitPat("b011010 ???????????????? ????? ?????"))
  val BGEU = Instruction("BGEU", TYPE_2RI16, BitPat("b011011 ???????????????? ????? ?????"))

  /* Common Access Memory Instructions */
  val LD_B  = Instruction("LD.B", TYPE_2RI12, BitPat("b00101 00000 ???????????? ????? ?????"))
  val LD_H  = Instruction("LD.H", TYPE_2RI12, BitPat("b00101 00001 ???????????? ????? ?????"))
  val LD_W  = Instruction("LD.W", TYPE_2RI12, BitPat("b00101 00010 ???????????? ????? ?????"))
  val ST_B  = Instruction("ST.B", TYPE_2RI12, BitPat("b00101 00100 ???????????? ????? ?????"))
  val ST_H  = Instruction("ST.H", TYPE_2RI12, BitPat("b00101 00101 ???????????? ????? ?????"))
  val ST_W  = Instruction("ST.W", TYPE_2RI12, BitPat("b00101 00110 ???????????? ????? ?????"))
  val LD_BU = Instruction("LD.BU", TYPE_2RI12, BitPat("b00101 01000 ???????????? ????? ?????"))
  val LD_HU = Instruction("LD.HU", TYPE_2RI12, BitPat("b00101 01001 ???????????? ????? ?????"))
  val PRELD = Instruction("PRELD", TYPE_2RI12, BitPat("b00101 01011 ???????????? ????? ?????"))

  /* Atomic Access Memory Instructions */
  val LL_W = Instruction("LL.W", TYPE_2RI14, BitPat("b00100000 ?????????????? ????? ?????"))
  val SC_W = Instruction("SC.W", TYPE_2RI14, BitPat("b00100001 ?????????????? ????? ?????"))

  /* Fence Instructions */
  val DBAR = Instruction("DBAR", TYPE_3R, BitPat("b0011 1000 0111 00100 ????? ????? ?????"))
  val IBAR = Instruction("IBAR", TYPE_3R, BitPat("b0011 1000 0111 00101 ????? ????? ?????"))

  /* Other Instructions */
  val BREAK       = Instruction("BREAK", TYPE_3R, BitPat("b0000 0000 0010 10100 ????? ????? ?????"))
  val SYSCALL     = Instruction("SYSCALL", TYPE_3R, BitPat("b0000 0000 0010 10110 ????? ????? ?????"))
  val RDCNTID_W_0 = Instruction("RDCNTID.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 1???? 00000"))
  val RDCNTID_W_1 = Instruction("RDCNTID.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 ?1??? 00000"))
  val RDCNTID_W_2 = Instruction("RDCNTID.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 ??1?? 00000"))
  val RDCNTID_W_3 = Instruction("RDCNTID.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 ???1? 00000"))
  val RDCNTID_W_4 = Instruction("RDCNTID.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 ????1 00000"))
  val RDCNTVL_W   = Instruction("RDCNTVL.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 00000 ?????"))
  val RDCNTVH_W   = Instruction("RDCNTVH.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11001 00000 ?????"))
  val RDTIMEL_W   = Instruction("RDTIMEL.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11000 ????? ?????"))
  val RDTIMEH_W   = Instruction("RDTIMEL.W", TYPE_2R, BitPat("b0000 0000 0000 00000 11001 ????? ?????"))

  /* CSR Access Instructions */
  val CSRRD     = Instruction("CSRRD", TYPE_2RI14, BitPat("b00000100 ?????????????? 00000 ?????"))
  val CSRWR     = Instruction("CSRWR", TYPE_2RI14, BitPat("b00000100 ?????????????? 00001 ?????"))
  val CSRXCHG_0 = Instruction("CSRXCHG", TYPE_2RI14, BitPat("b00000100 ?????????????? 1???? ?????"))
  val CSRXCHG_1 = Instruction("CSRXCHG", TYPE_2RI14, BitPat("b00000100 ?????????????? ?1??? ?????"))
  val CSRXCHG_2 = Instruction("CSRXCHG", TYPE_2RI14, BitPat("b00000100 ?????????????? ??1?? ?????"))
  val CSRXCHG_3 = Instruction("CSRXCHG", TYPE_2RI14, BitPat("b00000100 ?????????????? ???1? ?????"))

  /* Cache Maintenance Instructions */
  val CACOP = Instruction("CACOP", TYPE_2RI12, BitPat("b0000011000 ???????????? ????? ?????"))

  /* TLB Maintenance Instructions */
  val TLBSRCH = Instruction("TLBSRCH", TYPE_3R, BitPat("b0000 0110 0100 10000 01010 00000 00000"))
  val TLBRD   = Instruction("TLBRD", TYPE_3R, BitPat("b0000 0110 0100 10000 01011 00000 00000"))
  val TLBWR   = Instruction("TLBWR", TYPE_3R, BitPat("b0000 0110 0100 10000 01100 00000 00000"))
  val TLBFILL = Instruction("TLBFILL", TYPE_3R, BitPat("b0000 0110 0100 10000 01101 00000 00000"))
  val INVTLB  = Instruction("INVTLB", TYPE_3R, BitPat("b0000 0110 0100 10001 ????? ????? ?????"))

  /* Other miscellaneous directives */
  val ERTN = Instruction("ERTN", TYPE_3R, BitPat("b0000 0110 0100 10000 01110 00000 00000"))
  val IDLE = Instruction("IDLE", TYPE_3R, BitPat("b0000 0110 0100 10011 ????? ????? ?????"))
}

object Privilege {
  object PLV extends ChiselEnum {
    val PLV_0 = Value(0.U(2.W)) // User mode
    val PLV_3 = Value(3.U(2.W)) // Machine mode
  }

  object CACOPType extends ChiselEnum {
    val CACOP_FLUSH    = Value(0.U(2.W)) // flush cache line
    val CACOP_IDX_INV  = Value(1.U(2.W)) // invalidate indexed cache line
    val CACOP_HIT_INV  = Value(2.U(2.W)) // invalidate cache line if hit
    val CACOP_HIT_READ = Value(3.U(2.W)) // read cache line if hit
  }

  object ECODE extends ChiselEnum {
    def getEcode(e: UInt)    = e(4, 0)
    def getEsubCode(e: UInt) = e(5)

    val INT  = Value(0x00.U)
    val PIL  = Value(0x01.U)
    val PIS  = Value(0x02.U)
    val PIF  = Value(0x03.U)
    val PME  = Value(0x04.U)
    val PPI  = Value(0x07.U)
    val ADEF = Value(0x08.U)
    val ALE  = Value(0x09.U)
    val SYS  = Value(0x0b.U)
    val BRK  = Value(0x0c.U)
    val INE  = Value(0x0d.U)
    val IPE  = Value(0x0e.U)
    val FPD  = Value(0x0f.U)
    val FPE  = Value(0x12.U)
    val TLBR = Value(0x3f.U)
    val ADEM = Value(0x7f.U)
  }
}
